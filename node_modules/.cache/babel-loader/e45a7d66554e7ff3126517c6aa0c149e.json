{"ast":null,"code":"\"use client\";\n\nimport React from 'react';\nimport classNames from 'classnames';\nimport ResizeObserver from 'rc-resize-observer';\nimport omit from \"rc-util/es/omit\";\nimport throttleByAnimationFrame from '../_util/throttleByAnimationFrame';\nimport { ConfigContext } from '../config-provider';\nimport useStyle from './style';\nimport { getFixedBottom, getFixedTop, getTargetRect } from './utils';\nconst TRIGGER_EVENTS = ['resize', 'scroll', 'touchstart', 'touchmove', 'touchend', 'pageshow', 'load'];\n\nfunction getDefaultTarget() {\n  return typeof window !== 'undefined' ? window : null;\n}\n\nvar AffixStatus;\n\n(function (AffixStatus) {\n  AffixStatus[AffixStatus[\"None\"] = 0] = \"None\";\n  AffixStatus[AffixStatus[\"Prepare\"] = 1] = \"Prepare\";\n})(AffixStatus || (AffixStatus = {}));\n\nconst Affix = /*#__PURE__*/React.forwardRef((props, ref) => {\n  var _a;\n\n  const {\n    style,\n    offsetTop,\n    offsetBottom,\n    prefixCls,\n    className,\n    rootClassName,\n    children,\n    target,\n    onChange\n  } = props;\n  const {\n    getPrefixCls,\n    getTargetContainer\n  } = React.useContext(ConfigContext);\n  const affixPrefixCls = getPrefixCls('affix', prefixCls);\n  const [lastAffix, setLastAffix] = React.useState(false);\n  const [affixStyle, setAffixStyle] = React.useState();\n  const [placeholderStyle, setPlaceholderStyle] = React.useState();\n  const status = React.useRef(AffixStatus.None);\n  const prevTarget = React.useRef(null);\n  const prevListener = React.useRef();\n  const placeholderNodeRef = React.useRef(null);\n  const fixedNodeRef = React.useRef(null);\n  const timer = React.useRef(null);\n  const targetFunc = (_a = target !== null && target !== void 0 ? target : getTargetContainer) !== null && _a !== void 0 ? _a : getDefaultTarget;\n  const internalOffsetTop = offsetBottom === undefined && offsetTop === undefined ? 0 : offsetTop; // =================== Measure ===================\n\n  const measure = () => {\n    if (status.current !== AffixStatus.Prepare || !fixedNodeRef.current || !placeholderNodeRef.current || !targetFunc) {\n      return;\n    }\n\n    const targetNode = targetFunc();\n\n    if (targetNode) {\n      const newState = {\n        status: AffixStatus.None\n      };\n      const placeholderRect = getTargetRect(placeholderNodeRef.current);\n\n      if (placeholderRect.top === 0 && placeholderRect.left === 0 && placeholderRect.width === 0 && placeholderRect.height === 0) {\n        return;\n      }\n\n      const targetRect = getTargetRect(targetNode);\n      const fixedTop = getFixedTop(placeholderRect, targetRect, internalOffsetTop);\n      const fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom);\n\n      if (fixedTop !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          top: fixedTop,\n          width: placeholderRect.width,\n          height: placeholderRect.height\n        };\n        newState.placeholderStyle = {\n          width: placeholderRect.width,\n          height: placeholderRect.height\n        };\n      } else if (fixedBottom !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          bottom: fixedBottom,\n          width: placeholderRect.width,\n          height: placeholderRect.height\n        };\n        newState.placeholderStyle = {\n          width: placeholderRect.width,\n          height: placeholderRect.height\n        };\n      }\n\n      newState.lastAffix = !!newState.affixStyle;\n\n      if (lastAffix !== newState.lastAffix) {\n        onChange === null || onChange === void 0 ? void 0 : onChange(newState.lastAffix);\n      }\n\n      status.current = newState.status;\n      setAffixStyle(newState.affixStyle);\n      setPlaceholderStyle(newState.placeholderStyle);\n      setLastAffix(newState.lastAffix);\n    }\n  };\n\n  const prepareMeasure = () => {\n    var _a;\n\n    status.current = AffixStatus.Prepare;\n    measure();\n\n    if (process.env.NODE_ENV === 'test') {\n      (_a = props === null || props === void 0 ? void 0 : props.onTestUpdatePosition) === null || _a === void 0 ? void 0 : _a.call(props);\n    }\n  };\n\n  const updatePosition = throttleByAnimationFrame(() => {\n    prepareMeasure();\n  });\n  const lazyUpdatePosition = throttleByAnimationFrame(() => {\n    // Check position change before measure to make Safari smooth\n    if (targetFunc && affixStyle) {\n      const targetNode = targetFunc();\n\n      if (targetNode && placeholderNodeRef.current) {\n        const targetRect = getTargetRect(targetNode);\n        const placeholderRect = getTargetRect(placeholderNodeRef.current);\n        const fixedTop = getFixedTop(placeholderRect, targetRect, internalOffsetTop);\n        const fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom);\n\n        if (fixedTop !== undefined && affixStyle.top === fixedTop || fixedBottom !== undefined && affixStyle.bottom === fixedBottom) {\n          return;\n        }\n      }\n    } // Directly call prepare measure since it's already throttled.\n\n\n    prepareMeasure();\n  });\n\n  const addListeners = () => {\n    const listenerTarget = targetFunc === null || targetFunc === void 0 ? void 0 : targetFunc();\n\n    if (!listenerTarget) {\n      return;\n    }\n\n    TRIGGER_EVENTS.forEach(eventName => {\n      var _a;\n\n      if (prevListener.current) {\n        (_a = prevTarget.current) === null || _a === void 0 ? void 0 : _a.removeEventListener(eventName, prevListener.current);\n      }\n\n      listenerTarget === null || listenerTarget === void 0 ? void 0 : listenerTarget.addEventListener(eventName, lazyUpdatePosition);\n    });\n    prevTarget.current = listenerTarget;\n    prevListener.current = lazyUpdatePosition;\n  };\n\n  const removeListeners = () => {\n    if (timer.current) {\n      clearTimeout(timer.current);\n      timer.current = null;\n    }\n\n    const newTarget = targetFunc === null || targetFunc === void 0 ? void 0 : targetFunc();\n    TRIGGER_EVENTS.forEach(eventName => {\n      var _a;\n\n      newTarget === null || newTarget === void 0 ? void 0 : newTarget.removeEventListener(eventName, lazyUpdatePosition);\n\n      if (prevListener.current) {\n        (_a = prevTarget.current) === null || _a === void 0 ? void 0 : _a.removeEventListener(eventName, prevListener.current);\n      }\n    });\n    updatePosition.cancel();\n    lazyUpdatePosition.cancel();\n  };\n\n  React.useImperativeHandle(ref, () => ({\n    updatePosition\n  })); // mount & unmount\n\n  React.useEffect(() => {\n    // [Legacy] Wait for parent component ref has its value.\n    // We should use target as directly element instead of function which makes element check hard.\n    timer.current = setTimeout(addListeners);\n    return () => removeListeners();\n  }, []);\n  React.useEffect(() => {\n    addListeners();\n  }, [target, affixStyle]);\n  React.useEffect(() => {\n    updatePosition();\n  }, [target, offsetTop, offsetBottom]);\n  const [wrapCSSVar, hashId, cssVarCls] = useStyle(affixPrefixCls);\n  const rootCls = classNames(rootClassName, hashId, affixPrefixCls, cssVarCls);\n  const mergedCls = classNames({\n    [rootCls]: affixStyle\n  });\n  let otherProps = omit(props, ['prefixCls', 'offsetTop', 'offsetBottom', 'target', 'onChange', 'rootClassName']);\n\n  if (process.env.NODE_ENV === 'test') {\n    otherProps = omit(otherProps, ['onTestUpdatePosition']);\n  }\n\n  return wrapCSSVar( /*#__PURE__*/React.createElement(ResizeObserver, {\n    onResize: updatePosition\n  }, /*#__PURE__*/React.createElement(\"div\", Object.assign({\n    style: style,\n    className: className,\n    ref: placeholderNodeRef\n  }, otherProps), affixStyle && /*#__PURE__*/React.createElement(\"div\", {\n    style: placeholderStyle,\n    \"aria-hidden\": \"true\"\n  }), /*#__PURE__*/React.createElement(\"div\", {\n    className: mergedCls,\n    ref: fixedNodeRef,\n    style: affixStyle\n  }, /*#__PURE__*/React.createElement(ResizeObserver, {\n    onResize: updatePosition\n  }, children)))));\n});\n\nif (process.env.NODE_ENV !== 'production') {\n  Affix.displayName = 'Affix';\n}\n\nexport default Affix;","map":{"version":3,"names":["React","classNames","ResizeObserver","omit","throttleByAnimationFrame","ConfigContext","useStyle","getFixedBottom","getFixedTop","getTargetRect","TRIGGER_EVENTS","getDefaultTarget","window","AffixStatus","Affix","forwardRef","props","ref","_a","style","offsetTop","offsetBottom","prefixCls","className","rootClassName","children","target","onChange","getPrefixCls","getTargetContainer","useContext","affixPrefixCls","lastAffix","setLastAffix","useState","affixStyle","setAffixStyle","placeholderStyle","setPlaceholderStyle","status","useRef","None","prevTarget","prevListener","placeholderNodeRef","fixedNodeRef","timer","targetFunc","internalOffsetTop","undefined","measure","current","Prepare","targetNode","newState","placeholderRect","top","left","width","height","targetRect","fixedTop","fixedBottom","position","bottom","prepareMeasure","process","env","NODE_ENV","onTestUpdatePosition","call","updatePosition","lazyUpdatePosition","addListeners","listenerTarget","forEach","eventName","removeEventListener","addEventListener","removeListeners","clearTimeout","newTarget","cancel","useImperativeHandle","useEffect","setTimeout","wrapCSSVar","hashId","cssVarCls","rootCls","mergedCls","otherProps","createElement","onResize","Object","assign","displayName"],"sources":["/Users/joji/Downloads/react-cutioluis-main copy/node_modules/antd/es/affix/index.js"],"sourcesContent":["\"use client\";\n\nimport React from 'react';\nimport classNames from 'classnames';\nimport ResizeObserver from 'rc-resize-observer';\nimport omit from \"rc-util/es/omit\";\nimport throttleByAnimationFrame from '../_util/throttleByAnimationFrame';\nimport { ConfigContext } from '../config-provider';\nimport useStyle from './style';\nimport { getFixedBottom, getFixedTop, getTargetRect } from './utils';\nconst TRIGGER_EVENTS = ['resize', 'scroll', 'touchstart', 'touchmove', 'touchend', 'pageshow', 'load'];\nfunction getDefaultTarget() {\n  return typeof window !== 'undefined' ? window : null;\n}\nvar AffixStatus;\n(function (AffixStatus) {\n  AffixStatus[AffixStatus[\"None\"] = 0] = \"None\";\n  AffixStatus[AffixStatus[\"Prepare\"] = 1] = \"Prepare\";\n})(AffixStatus || (AffixStatus = {}));\nconst Affix = /*#__PURE__*/React.forwardRef((props, ref) => {\n  var _a;\n  const {\n    style,\n    offsetTop,\n    offsetBottom,\n    prefixCls,\n    className,\n    rootClassName,\n    children,\n    target,\n    onChange\n  } = props;\n  const {\n    getPrefixCls,\n    getTargetContainer\n  } = React.useContext(ConfigContext);\n  const affixPrefixCls = getPrefixCls('affix', prefixCls);\n  const [lastAffix, setLastAffix] = React.useState(false);\n  const [affixStyle, setAffixStyle] = React.useState();\n  const [placeholderStyle, setPlaceholderStyle] = React.useState();\n  const status = React.useRef(AffixStatus.None);\n  const prevTarget = React.useRef(null);\n  const prevListener = React.useRef();\n  const placeholderNodeRef = React.useRef(null);\n  const fixedNodeRef = React.useRef(null);\n  const timer = React.useRef(null);\n  const targetFunc = (_a = target !== null && target !== void 0 ? target : getTargetContainer) !== null && _a !== void 0 ? _a : getDefaultTarget;\n  const internalOffsetTop = offsetBottom === undefined && offsetTop === undefined ? 0 : offsetTop;\n  // =================== Measure ===================\n  const measure = () => {\n    if (status.current !== AffixStatus.Prepare || !fixedNodeRef.current || !placeholderNodeRef.current || !targetFunc) {\n      return;\n    }\n    const targetNode = targetFunc();\n    if (targetNode) {\n      const newState = {\n        status: AffixStatus.None\n      };\n      const placeholderRect = getTargetRect(placeholderNodeRef.current);\n      if (placeholderRect.top === 0 && placeholderRect.left === 0 && placeholderRect.width === 0 && placeholderRect.height === 0) {\n        return;\n      }\n      const targetRect = getTargetRect(targetNode);\n      const fixedTop = getFixedTop(placeholderRect, targetRect, internalOffsetTop);\n      const fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom);\n      if (fixedTop !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          top: fixedTop,\n          width: placeholderRect.width,\n          height: placeholderRect.height\n        };\n        newState.placeholderStyle = {\n          width: placeholderRect.width,\n          height: placeholderRect.height\n        };\n      } else if (fixedBottom !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          bottom: fixedBottom,\n          width: placeholderRect.width,\n          height: placeholderRect.height\n        };\n        newState.placeholderStyle = {\n          width: placeholderRect.width,\n          height: placeholderRect.height\n        };\n      }\n      newState.lastAffix = !!newState.affixStyle;\n      if (lastAffix !== newState.lastAffix) {\n        onChange === null || onChange === void 0 ? void 0 : onChange(newState.lastAffix);\n      }\n      status.current = newState.status;\n      setAffixStyle(newState.affixStyle);\n      setPlaceholderStyle(newState.placeholderStyle);\n      setLastAffix(newState.lastAffix);\n    }\n  };\n  const prepareMeasure = () => {\n    var _a;\n    status.current = AffixStatus.Prepare;\n    measure();\n    if (process.env.NODE_ENV === 'test') {\n      (_a = props === null || props === void 0 ? void 0 : props.onTestUpdatePosition) === null || _a === void 0 ? void 0 : _a.call(props);\n    }\n  };\n  const updatePosition = throttleByAnimationFrame(() => {\n    prepareMeasure();\n  });\n  const lazyUpdatePosition = throttleByAnimationFrame(() => {\n    // Check position change before measure to make Safari smooth\n    if (targetFunc && affixStyle) {\n      const targetNode = targetFunc();\n      if (targetNode && placeholderNodeRef.current) {\n        const targetRect = getTargetRect(targetNode);\n        const placeholderRect = getTargetRect(placeholderNodeRef.current);\n        const fixedTop = getFixedTop(placeholderRect, targetRect, internalOffsetTop);\n        const fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom);\n        if (fixedTop !== undefined && affixStyle.top === fixedTop || fixedBottom !== undefined && affixStyle.bottom === fixedBottom) {\n          return;\n        }\n      }\n    }\n    // Directly call prepare measure since it's already throttled.\n    prepareMeasure();\n  });\n  const addListeners = () => {\n    const listenerTarget = targetFunc === null || targetFunc === void 0 ? void 0 : targetFunc();\n    if (!listenerTarget) {\n      return;\n    }\n    TRIGGER_EVENTS.forEach(eventName => {\n      var _a;\n      if (prevListener.current) {\n        (_a = prevTarget.current) === null || _a === void 0 ? void 0 : _a.removeEventListener(eventName, prevListener.current);\n      }\n      listenerTarget === null || listenerTarget === void 0 ? void 0 : listenerTarget.addEventListener(eventName, lazyUpdatePosition);\n    });\n    prevTarget.current = listenerTarget;\n    prevListener.current = lazyUpdatePosition;\n  };\n  const removeListeners = () => {\n    if (timer.current) {\n      clearTimeout(timer.current);\n      timer.current = null;\n    }\n    const newTarget = targetFunc === null || targetFunc === void 0 ? void 0 : targetFunc();\n    TRIGGER_EVENTS.forEach(eventName => {\n      var _a;\n      newTarget === null || newTarget === void 0 ? void 0 : newTarget.removeEventListener(eventName, lazyUpdatePosition);\n      if (prevListener.current) {\n        (_a = prevTarget.current) === null || _a === void 0 ? void 0 : _a.removeEventListener(eventName, prevListener.current);\n      }\n    });\n    updatePosition.cancel();\n    lazyUpdatePosition.cancel();\n  };\n  React.useImperativeHandle(ref, () => ({\n    updatePosition\n  }));\n  // mount & unmount\n  React.useEffect(() => {\n    // [Legacy] Wait for parent component ref has its value.\n    // We should use target as directly element instead of function which makes element check hard.\n    timer.current = setTimeout(addListeners);\n    return () => removeListeners();\n  }, []);\n  React.useEffect(() => {\n    addListeners();\n  }, [target, affixStyle]);\n  React.useEffect(() => {\n    updatePosition();\n  }, [target, offsetTop, offsetBottom]);\n  const [wrapCSSVar, hashId, cssVarCls] = useStyle(affixPrefixCls);\n  const rootCls = classNames(rootClassName, hashId, affixPrefixCls, cssVarCls);\n  const mergedCls = classNames({\n    [rootCls]: affixStyle\n  });\n  let otherProps = omit(props, ['prefixCls', 'offsetTop', 'offsetBottom', 'target', 'onChange', 'rootClassName']);\n  if (process.env.NODE_ENV === 'test') {\n    otherProps = omit(otherProps, ['onTestUpdatePosition']);\n  }\n  return wrapCSSVar( /*#__PURE__*/React.createElement(ResizeObserver, {\n    onResize: updatePosition\n  }, /*#__PURE__*/React.createElement(\"div\", Object.assign({\n    style: style,\n    className: className,\n    ref: placeholderNodeRef\n  }, otherProps), affixStyle && /*#__PURE__*/React.createElement(\"div\", {\n    style: placeholderStyle,\n    \"aria-hidden\": \"true\"\n  }), /*#__PURE__*/React.createElement(\"div\", {\n    className: mergedCls,\n    ref: fixedNodeRef,\n    style: affixStyle\n  }, /*#__PURE__*/React.createElement(ResizeObserver, {\n    onResize: updatePosition\n  }, children)))));\n});\nif (process.env.NODE_ENV !== 'production') {\n  Affix.displayName = 'Affix';\n}\nexport default Affix;"],"mappings":"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"},"metadata":{},"sourceType":"module"}