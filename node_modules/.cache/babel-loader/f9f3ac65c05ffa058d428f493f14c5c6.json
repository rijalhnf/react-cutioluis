{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { useState, useRef, useEffect } from 'react';\nimport addEventListener from \"rc-util/es/Dom/addEventListener\";\nimport getFixScaleEleTransPosition from \"../getFixScaleEleTransPosition\";\n\nfunction getDistance(a, b) {\n  var x = a.x - b.x;\n  var y = a.y - b.y;\n  return Math.hypot(x, y);\n}\n\nfunction getCenter(oldPoint1, oldPoint2, newPoint1, newPoint2) {\n  // Calculate the distance each point has moved\n  var distance1 = getDistance(oldPoint1, newPoint1);\n  var distance2 = getDistance(oldPoint2, newPoint2); // If both distances are 0, return the original points\n\n  if (distance1 === 0 && distance2 === 0) {\n    return [oldPoint1.x, oldPoint1.y];\n  } // Calculate the ratio of the distances\n\n\n  var ratio = distance1 / (distance1 + distance2); // Calculate the new center point based on the ratio\n\n  var x = oldPoint1.x + ratio * (oldPoint2.x - oldPoint1.x);\n  var y = oldPoint1.y + ratio * (oldPoint2.y - oldPoint1.y);\n  return [x, y];\n}\n\nexport default function useTouchEvent(imgRef, movable, visible, minScale, transform, updateTransform, dispatchZoomChange) {\n  var rotate = transform.rotate,\n      scale = transform.scale,\n      x = transform.x,\n      y = transform.y;\n\n  var _useState = useState(false),\n      _useState2 = _slicedToArray(_useState, 2),\n      isTouching = _useState2[0],\n      setIsTouching = _useState2[1];\n\n  var touchPointInfo = useRef({\n    point1: {\n      x: 0,\n      y: 0\n    },\n    point2: {\n      x: 0,\n      y: 0\n    },\n    eventType: 'none'\n  });\n\n  var updateTouchPointInfo = function updateTouchPointInfo(values) {\n    touchPointInfo.current = _objectSpread(_objectSpread({}, touchPointInfo.current), values);\n  };\n\n  var onTouchStart = function onTouchStart(event) {\n    if (!movable) return;\n    event.stopPropagation();\n    setIsTouching(true);\n    var _event$touches = event.touches,\n        touches = _event$touches === void 0 ? [] : _event$touches;\n\n    if (touches.length > 1) {\n      // touch zoom\n      updateTouchPointInfo({\n        point1: {\n          x: touches[0].clientX,\n          y: touches[0].clientY\n        },\n        point2: {\n          x: touches[1].clientX,\n          y: touches[1].clientY\n        },\n        eventType: 'touchZoom'\n      });\n    } else {\n      // touch move\n      updateTouchPointInfo({\n        point1: {\n          x: touches[0].clientX - x,\n          y: touches[0].clientY - y\n        },\n        eventType: 'move'\n      });\n    }\n  };\n\n  var onTouchMove = function onTouchMove(event) {\n    var _event$touches2 = event.touches,\n        touches = _event$touches2 === void 0 ? [] : _event$touches2;\n    var _touchPointInfo$curre = touchPointInfo.current,\n        point1 = _touchPointInfo$curre.point1,\n        point2 = _touchPointInfo$curre.point2,\n        eventType = _touchPointInfo$curre.eventType;\n\n    if (touches.length > 1 && eventType === 'touchZoom') {\n      // touch zoom\n      var newPoint1 = {\n        x: touches[0].clientX,\n        y: touches[0].clientY\n      };\n      var newPoint2 = {\n        x: touches[1].clientX,\n        y: touches[1].clientY\n      };\n\n      var _getCenter = getCenter(point1, point2, newPoint1, newPoint2),\n          _getCenter2 = _slicedToArray(_getCenter, 2),\n          centerX = _getCenter2[0],\n          centerY = _getCenter2[1];\n\n      var ratio = getDistance(newPoint1, newPoint2) / getDistance(point1, point2);\n      dispatchZoomChange(ratio, 'touchZoom', centerX, centerY, true);\n      updateTouchPointInfo({\n        point1: newPoint1,\n        point2: newPoint2,\n        eventType: 'touchZoom'\n      });\n    } else if (eventType === 'move') {\n      // touch move\n      updateTransform({\n        x: touches[0].clientX - point1.x,\n        y: touches[0].clientY - point1.y\n      }, 'move');\n      updateTouchPointInfo({\n        eventType: 'move'\n      });\n    }\n  };\n\n  var onTouchEnd = function onTouchEnd() {\n    if (!visible) return;\n\n    if (isTouching) {\n      setIsTouching(false);\n    }\n\n    updateTouchPointInfo({\n      eventType: 'none'\n    });\n\n    if (minScale > scale) {\n      /** When the scaling ratio is less than the minimum scaling ratio, reset the scaling ratio */\n      return updateTransform({\n        x: 0,\n        y: 0,\n        scale: minScale\n      }, 'touchZoom');\n    }\n\n    var width = imgRef.current.offsetWidth * scale;\n    var height = imgRef.current.offsetHeight * scale; // eslint-disable-next-line @typescript-eslint/no-shadow\n\n    var _imgRef$current$getBo = imgRef.current.getBoundingClientRect(),\n        left = _imgRef$current$getBo.left,\n        top = _imgRef$current$getBo.top;\n\n    var isRotate = rotate % 180 !== 0;\n    var fixState = getFixScaleEleTransPosition(isRotate ? height : width, isRotate ? width : height, left, top);\n\n    if (fixState) {\n      updateTransform(_objectSpread({}, fixState), 'dragRebound');\n    }\n  };\n\n  useEffect(function () {\n    var onTouchMoveListener;\n\n    if (visible && movable) {\n      onTouchMoveListener = addEventListener(window, 'touchmove', function (e) {\n        return e.preventDefault();\n      }, {\n        passive: false\n      });\n    }\n\n    return function () {\n      var _onTouchMoveListener;\n\n      (_onTouchMoveListener = onTouchMoveListener) === null || _onTouchMoveListener === void 0 || _onTouchMoveListener.remove();\n    };\n  }, [visible, movable]);\n  return {\n    isTouching: isTouching,\n    onTouchStart: onTouchStart,\n    onTouchMove: onTouchMove,\n    onTouchEnd: onTouchEnd\n  };\n}\n;","map":{"version":3,"names":["_objectSpread","_slicedToArray","useState","useRef","useEffect","addEventListener","getFixScaleEleTransPosition","getDistance","a","b","x","y","Math","hypot","getCenter","oldPoint1","oldPoint2","newPoint1","newPoint2","distance1","distance2","ratio","useTouchEvent","imgRef","movable","visible","minScale","transform","updateTransform","dispatchZoomChange","rotate","scale","_useState","_useState2","isTouching","setIsTouching","touchPointInfo","point1","point2","eventType","updateTouchPointInfo","values","current","onTouchStart","event","stopPropagation","_event$touches","touches","length","clientX","clientY","onTouchMove","_event$touches2","_touchPointInfo$curre","_getCenter","_getCenter2","centerX","centerY","onTouchEnd","width","offsetWidth","height","offsetHeight","_imgRef$current$getBo","getBoundingClientRect","left","top","isRotate","fixState","onTouchMoveListener","window","e","preventDefault","passive","_onTouchMoveListener","remove"],"sources":["/Users/joji/Downloads/react-cutioluis-main copy/node_modules/rc-image/es/hooks/useTouchEvent.js"],"sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { useState, useRef, useEffect } from 'react';\nimport addEventListener from \"rc-util/es/Dom/addEventListener\";\nimport getFixScaleEleTransPosition from \"../getFixScaleEleTransPosition\";\nfunction getDistance(a, b) {\n  var x = a.x - b.x;\n  var y = a.y - b.y;\n  return Math.hypot(x, y);\n}\nfunction getCenter(oldPoint1, oldPoint2, newPoint1, newPoint2) {\n  // Calculate the distance each point has moved\n  var distance1 = getDistance(oldPoint1, newPoint1);\n  var distance2 = getDistance(oldPoint2, newPoint2);\n\n  // If both distances are 0, return the original points\n  if (distance1 === 0 && distance2 === 0) {\n    return [oldPoint1.x, oldPoint1.y];\n  }\n\n  // Calculate the ratio of the distances\n  var ratio = distance1 / (distance1 + distance2);\n\n  // Calculate the new center point based on the ratio\n  var x = oldPoint1.x + ratio * (oldPoint2.x - oldPoint1.x);\n  var y = oldPoint1.y + ratio * (oldPoint2.y - oldPoint1.y);\n  return [x, y];\n}\nexport default function useTouchEvent(imgRef, movable, visible, minScale, transform, updateTransform, dispatchZoomChange) {\n  var rotate = transform.rotate,\n    scale = transform.scale,\n    x = transform.x,\n    y = transform.y;\n  var _useState = useState(false),\n    _useState2 = _slicedToArray(_useState, 2),\n    isTouching = _useState2[0],\n    setIsTouching = _useState2[1];\n  var touchPointInfo = useRef({\n    point1: {\n      x: 0,\n      y: 0\n    },\n    point2: {\n      x: 0,\n      y: 0\n    },\n    eventType: 'none'\n  });\n  var updateTouchPointInfo = function updateTouchPointInfo(values) {\n    touchPointInfo.current = _objectSpread(_objectSpread({}, touchPointInfo.current), values);\n  };\n  var onTouchStart = function onTouchStart(event) {\n    if (!movable) return;\n    event.stopPropagation();\n    setIsTouching(true);\n    var _event$touches = event.touches,\n      touches = _event$touches === void 0 ? [] : _event$touches;\n    if (touches.length > 1) {\n      // touch zoom\n      updateTouchPointInfo({\n        point1: {\n          x: touches[0].clientX,\n          y: touches[0].clientY\n        },\n        point2: {\n          x: touches[1].clientX,\n          y: touches[1].clientY\n        },\n        eventType: 'touchZoom'\n      });\n    } else {\n      // touch move\n      updateTouchPointInfo({\n        point1: {\n          x: touches[0].clientX - x,\n          y: touches[0].clientY - y\n        },\n        eventType: 'move'\n      });\n    }\n  };\n  var onTouchMove = function onTouchMove(event) {\n    var _event$touches2 = event.touches,\n      touches = _event$touches2 === void 0 ? [] : _event$touches2;\n    var _touchPointInfo$curre = touchPointInfo.current,\n      point1 = _touchPointInfo$curre.point1,\n      point2 = _touchPointInfo$curre.point2,\n      eventType = _touchPointInfo$curre.eventType;\n    if (touches.length > 1 && eventType === 'touchZoom') {\n      // touch zoom\n      var newPoint1 = {\n        x: touches[0].clientX,\n        y: touches[0].clientY\n      };\n      var newPoint2 = {\n        x: touches[1].clientX,\n        y: touches[1].clientY\n      };\n      var _getCenter = getCenter(point1, point2, newPoint1, newPoint2),\n        _getCenter2 = _slicedToArray(_getCenter, 2),\n        centerX = _getCenter2[0],\n        centerY = _getCenter2[1];\n      var ratio = getDistance(newPoint1, newPoint2) / getDistance(point1, point2);\n      dispatchZoomChange(ratio, 'touchZoom', centerX, centerY, true);\n      updateTouchPointInfo({\n        point1: newPoint1,\n        point2: newPoint2,\n        eventType: 'touchZoom'\n      });\n    } else if (eventType === 'move') {\n      // touch move\n      updateTransform({\n        x: touches[0].clientX - point1.x,\n        y: touches[0].clientY - point1.y\n      }, 'move');\n      updateTouchPointInfo({\n        eventType: 'move'\n      });\n    }\n  };\n  var onTouchEnd = function onTouchEnd() {\n    if (!visible) return;\n    if (isTouching) {\n      setIsTouching(false);\n    }\n    updateTouchPointInfo({\n      eventType: 'none'\n    });\n    if (minScale > scale) {\n      /** When the scaling ratio is less than the minimum scaling ratio, reset the scaling ratio */\n      return updateTransform({\n        x: 0,\n        y: 0,\n        scale: minScale\n      }, 'touchZoom');\n    }\n    var width = imgRef.current.offsetWidth * scale;\n    var height = imgRef.current.offsetHeight * scale;\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    var _imgRef$current$getBo = imgRef.current.getBoundingClientRect(),\n      left = _imgRef$current$getBo.left,\n      top = _imgRef$current$getBo.top;\n    var isRotate = rotate % 180 !== 0;\n    var fixState = getFixScaleEleTransPosition(isRotate ? height : width, isRotate ? width : height, left, top);\n    if (fixState) {\n      updateTransform(_objectSpread({}, fixState), 'dragRebound');\n    }\n  };\n  useEffect(function () {\n    var onTouchMoveListener;\n    if (visible && movable) {\n      onTouchMoveListener = addEventListener(window, 'touchmove', function (e) {\n        return e.preventDefault();\n      }, {\n        passive: false\n      });\n    }\n    return function () {\n      var _onTouchMoveListener;\n      (_onTouchMoveListener = onTouchMoveListener) === null || _onTouchMoveListener === void 0 || _onTouchMoveListener.remove();\n    };\n  }, [visible, movable]);\n  return {\n    isTouching: isTouching,\n    onTouchStart: onTouchStart,\n    onTouchMove: onTouchMove,\n    onTouchEnd: onTouchEnd\n  };\n}\n;"],"mappings":"AAAA,OAAOA,aAAP,MAA0B,0CAA1B;AACA,OAAOC,cAAP,MAA2B,0CAA3B;AACA,SAASC,QAAT,EAAmBC,MAAnB,EAA2BC,SAA3B,QAA4C,OAA5C;AACA,OAAOC,gBAAP,MAA6B,iCAA7B;AACA,OAAOC,2BAAP,MAAwC,gCAAxC;;AACA,SAASC,WAAT,CAAqBC,CAArB,EAAwBC,CAAxB,EAA2B;EACzB,IAAIC,CAAC,GAAGF,CAAC,CAACE,CAAF,GAAMD,CAAC,CAACC,CAAhB;EACA,IAAIC,CAAC,GAAGH,CAAC,CAACG,CAAF,GAAMF,CAAC,CAACE,CAAhB;EACA,OAAOC,IAAI,CAACC,KAAL,CAAWH,CAAX,EAAcC,CAAd,CAAP;AACD;;AACD,SAASG,SAAT,CAAmBC,SAAnB,EAA8BC,SAA9B,EAAyCC,SAAzC,EAAoDC,SAApD,EAA+D;EAC7D;EACA,IAAIC,SAAS,GAAGZ,WAAW,CAACQ,SAAD,EAAYE,SAAZ,CAA3B;EACA,IAAIG,SAAS,GAAGb,WAAW,CAACS,SAAD,EAAYE,SAAZ,CAA3B,CAH6D,CAK7D;;EACA,IAAIC,SAAS,KAAK,CAAd,IAAmBC,SAAS,KAAK,CAArC,EAAwC;IACtC,OAAO,CAACL,SAAS,CAACL,CAAX,EAAcK,SAAS,CAACJ,CAAxB,CAAP;EACD,CAR4D,CAU7D;;;EACA,IAAIU,KAAK,GAAGF,SAAS,IAAIA,SAAS,GAAGC,SAAhB,CAArB,CAX6D,CAa7D;;EACA,IAAIV,CAAC,GAAGK,SAAS,CAACL,CAAV,GAAcW,KAAK,IAAIL,SAAS,CAACN,CAAV,GAAcK,SAAS,CAACL,CAA5B,CAA3B;EACA,IAAIC,CAAC,GAAGI,SAAS,CAACJ,CAAV,GAAcU,KAAK,IAAIL,SAAS,CAACL,CAAV,GAAcI,SAAS,CAACJ,CAA5B,CAA3B;EACA,OAAO,CAACD,CAAD,EAAIC,CAAJ,CAAP;AACD;;AACD,eAAe,SAASW,aAAT,CAAuBC,MAAvB,EAA+BC,OAA/B,EAAwCC,OAAxC,EAAiDC,QAAjD,EAA2DC,SAA3D,EAAsEC,eAAtE,EAAuFC,kBAAvF,EAA2G;EACxH,IAAIC,MAAM,GAAGH,SAAS,CAACG,MAAvB;EAAA,IACEC,KAAK,GAAGJ,SAAS,CAACI,KADpB;EAAA,IAEErB,CAAC,GAAGiB,SAAS,CAACjB,CAFhB;EAAA,IAGEC,CAAC,GAAGgB,SAAS,CAAChB,CAHhB;;EAIA,IAAIqB,SAAS,GAAG9B,QAAQ,CAAC,KAAD,CAAxB;EAAA,IACE+B,UAAU,GAAGhC,cAAc,CAAC+B,SAAD,EAAY,CAAZ,CAD7B;EAAA,IAEEE,UAAU,GAAGD,UAAU,CAAC,CAAD,CAFzB;EAAA,IAGEE,aAAa,GAAGF,UAAU,CAAC,CAAD,CAH5B;;EAIA,IAAIG,cAAc,GAAGjC,MAAM,CAAC;IAC1BkC,MAAM,EAAE;MACN3B,CAAC,EAAE,CADG;MAENC,CAAC,EAAE;IAFG,CADkB;IAK1B2B,MAAM,EAAE;MACN5B,CAAC,EAAE,CADG;MAENC,CAAC,EAAE;IAFG,CALkB;IAS1B4B,SAAS,EAAE;EATe,CAAD,CAA3B;;EAWA,IAAIC,oBAAoB,GAAG,SAASA,oBAAT,CAA8BC,MAA9B,EAAsC;IAC/DL,cAAc,CAACM,OAAf,GAAyB1C,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKoC,cAAc,CAACM,OAApB,CAAd,EAA4CD,MAA5C,CAAtC;EACD,CAFD;;EAGA,IAAIE,YAAY,GAAG,SAASA,YAAT,CAAsBC,KAAtB,EAA6B;IAC9C,IAAI,CAACpB,OAAL,EAAc;IACdoB,KAAK,CAACC,eAAN;IACAV,aAAa,CAAC,IAAD,CAAb;IACA,IAAIW,cAAc,GAAGF,KAAK,CAACG,OAA3B;IAAA,IACEA,OAAO,GAAGD,cAAc,KAAK,KAAK,CAAxB,GAA4B,EAA5B,GAAiCA,cAD7C;;IAEA,IAAIC,OAAO,CAACC,MAAR,GAAiB,CAArB,EAAwB;MACtB;MACAR,oBAAoB,CAAC;QACnBH,MAAM,EAAE;UACN3B,CAAC,EAAEqC,OAAO,CAAC,CAAD,CAAP,CAAWE,OADR;UAENtC,CAAC,EAAEoC,OAAO,CAAC,CAAD,CAAP,CAAWG;QAFR,CADW;QAKnBZ,MAAM,EAAE;UACN5B,CAAC,EAAEqC,OAAO,CAAC,CAAD,CAAP,CAAWE,OADR;UAENtC,CAAC,EAAEoC,OAAO,CAAC,CAAD,CAAP,CAAWG;QAFR,CALW;QASnBX,SAAS,EAAE;MATQ,CAAD,CAApB;IAWD,CAbD,MAaO;MACL;MACAC,oBAAoB,CAAC;QACnBH,MAAM,EAAE;UACN3B,CAAC,EAAEqC,OAAO,CAAC,CAAD,CAAP,CAAWE,OAAX,GAAqBvC,CADlB;UAENC,CAAC,EAAEoC,OAAO,CAAC,CAAD,CAAP,CAAWG,OAAX,GAAqBvC;QAFlB,CADW;QAKnB4B,SAAS,EAAE;MALQ,CAAD,CAApB;IAOD;EACF,CA7BD;;EA8BA,IAAIY,WAAW,GAAG,SAASA,WAAT,CAAqBP,KAArB,EAA4B;IAC5C,IAAIQ,eAAe,GAAGR,KAAK,CAACG,OAA5B;IAAA,IACEA,OAAO,GAAGK,eAAe,KAAK,KAAK,CAAzB,GAA6B,EAA7B,GAAkCA,eAD9C;IAEA,IAAIC,qBAAqB,GAAGjB,cAAc,CAACM,OAA3C;IAAA,IACEL,MAAM,GAAGgB,qBAAqB,CAAChB,MADjC;IAAA,IAEEC,MAAM,GAAGe,qBAAqB,CAACf,MAFjC;IAAA,IAGEC,SAAS,GAAGc,qBAAqB,CAACd,SAHpC;;IAIA,IAAIQ,OAAO,CAACC,MAAR,GAAiB,CAAjB,IAAsBT,SAAS,KAAK,WAAxC,EAAqD;MACnD;MACA,IAAItB,SAAS,GAAG;QACdP,CAAC,EAAEqC,OAAO,CAAC,CAAD,CAAP,CAAWE,OADA;QAEdtC,CAAC,EAAEoC,OAAO,CAAC,CAAD,CAAP,CAAWG;MAFA,CAAhB;MAIA,IAAIhC,SAAS,GAAG;QACdR,CAAC,EAAEqC,OAAO,CAAC,CAAD,CAAP,CAAWE,OADA;QAEdtC,CAAC,EAAEoC,OAAO,CAAC,CAAD,CAAP,CAAWG;MAFA,CAAhB;;MAIA,IAAII,UAAU,GAAGxC,SAAS,CAACuB,MAAD,EAASC,MAAT,EAAiBrB,SAAjB,EAA4BC,SAA5B,CAA1B;MAAA,IACEqC,WAAW,GAAGtD,cAAc,CAACqD,UAAD,EAAa,CAAb,CAD9B;MAAA,IAEEE,OAAO,GAAGD,WAAW,CAAC,CAAD,CAFvB;MAAA,IAGEE,OAAO,GAAGF,WAAW,CAAC,CAAD,CAHvB;;MAIA,IAAIlC,KAAK,GAAGd,WAAW,CAACU,SAAD,EAAYC,SAAZ,CAAX,GAAoCX,WAAW,CAAC8B,MAAD,EAASC,MAAT,CAA3D;MACAT,kBAAkB,CAACR,KAAD,EAAQ,WAAR,EAAqBmC,OAArB,EAA8BC,OAA9B,EAAuC,IAAvC,CAAlB;MACAjB,oBAAoB,CAAC;QACnBH,MAAM,EAAEpB,SADW;QAEnBqB,MAAM,EAAEpB,SAFW;QAGnBqB,SAAS,EAAE;MAHQ,CAAD,CAApB;IAKD,CArBD,MAqBO,IAAIA,SAAS,KAAK,MAAlB,EAA0B;MAC/B;MACAX,eAAe,CAAC;QACdlB,CAAC,EAAEqC,OAAO,CAAC,CAAD,CAAP,CAAWE,OAAX,GAAqBZ,MAAM,CAAC3B,CADjB;QAEdC,CAAC,EAAEoC,OAAO,CAAC,CAAD,CAAP,CAAWG,OAAX,GAAqBb,MAAM,CAAC1B;MAFjB,CAAD,EAGZ,MAHY,CAAf;MAIA6B,oBAAoB,CAAC;QACnBD,SAAS,EAAE;MADQ,CAAD,CAApB;IAGD;EACF,CAtCD;;EAuCA,IAAImB,UAAU,GAAG,SAASA,UAAT,GAAsB;IACrC,IAAI,CAACjC,OAAL,EAAc;;IACd,IAAIS,UAAJ,EAAgB;MACdC,aAAa,CAAC,KAAD,CAAb;IACD;;IACDK,oBAAoB,CAAC;MACnBD,SAAS,EAAE;IADQ,CAAD,CAApB;;IAGA,IAAIb,QAAQ,GAAGK,KAAf,EAAsB;MACpB;MACA,OAAOH,eAAe,CAAC;QACrBlB,CAAC,EAAE,CADkB;QAErBC,CAAC,EAAE,CAFkB;QAGrBoB,KAAK,EAAEL;MAHc,CAAD,EAInB,WAJmB,CAAtB;IAKD;;IACD,IAAIiC,KAAK,GAAGpC,MAAM,CAACmB,OAAP,CAAekB,WAAf,GAA6B7B,KAAzC;IACA,IAAI8B,MAAM,GAAGtC,MAAM,CAACmB,OAAP,CAAeoB,YAAf,GAA8B/B,KAA3C,CAjBqC,CAkBrC;;IACA,IAAIgC,qBAAqB,GAAGxC,MAAM,CAACmB,OAAP,CAAesB,qBAAf,EAA5B;IAAA,IACEC,IAAI,GAAGF,qBAAqB,CAACE,IAD/B;IAAA,IAEEC,GAAG,GAAGH,qBAAqB,CAACG,GAF9B;;IAGA,IAAIC,QAAQ,GAAGrC,MAAM,GAAG,GAAT,KAAiB,CAAhC;IACA,IAAIsC,QAAQ,GAAG9D,2BAA2B,CAAC6D,QAAQ,GAAGN,MAAH,GAAYF,KAArB,EAA4BQ,QAAQ,GAAGR,KAAH,GAAWE,MAA/C,EAAuDI,IAAvD,EAA6DC,GAA7D,CAA1C;;IACA,IAAIE,QAAJ,EAAc;MACZxC,eAAe,CAAC5B,aAAa,CAAC,EAAD,EAAKoE,QAAL,CAAd,EAA8B,aAA9B,CAAf;IACD;EACF,CA3BD;;EA4BAhE,SAAS,CAAC,YAAY;IACpB,IAAIiE,mBAAJ;;IACA,IAAI5C,OAAO,IAAID,OAAf,EAAwB;MACtB6C,mBAAmB,GAAGhE,gBAAgB,CAACiE,MAAD,EAAS,WAAT,EAAsB,UAAUC,CAAV,EAAa;QACvE,OAAOA,CAAC,CAACC,cAAF,EAAP;MACD,CAFqC,EAEnC;QACDC,OAAO,EAAE;MADR,CAFmC,CAAtC;IAKD;;IACD,OAAO,YAAY;MACjB,IAAIC,oBAAJ;;MACA,CAACA,oBAAoB,GAAGL,mBAAxB,MAAiD,IAAjD,IAAyDK,oBAAoB,KAAK,KAAK,CAAvF,IAA4FA,oBAAoB,CAACC,MAArB,EAA5F;IACD,CAHD;EAID,CAbQ,EAaN,CAAClD,OAAD,EAAUD,OAAV,CAbM,CAAT;EAcA,OAAO;IACLU,UAAU,EAAEA,UADP;IAELS,YAAY,EAAEA,YAFT;IAGLQ,WAAW,EAAEA,WAHR;IAILO,UAAU,EAAEA;EAJP,CAAP;AAMD;AACD"},"metadata":{},"sourceType":"module"}