{"ast":null,"code":"import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\n/* eslint-disable no-param-reassign */\n\nimport * as React from 'react';\nimport raf from \"rc-util/es/raf\";\nimport useLayoutEffect from \"rc-util/es/hooks/useLayoutEffect\";\nimport { warning } from 'rc-util';\nvar MAX_TIMES = 10;\nexport default function useScrollTo(containerRef, data, heights, itemHeight, getKey, collectHeight, syncScrollTop, triggerFlash) {\n  var scrollRef = React.useRef();\n\n  var _React$useState = React.useState(null),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      syncState = _React$useState2[0],\n      setSyncState = _React$useState2[1]; // ========================== Sync Scroll ==========================\n\n\n  useLayoutEffect(function () {\n    if (syncState && syncState.times < MAX_TIMES) {\n      // Never reach\n      if (!containerRef.current) {\n        setSyncState(function (ori) {\n          return _objectSpread({}, ori);\n        });\n        return;\n      }\n\n      collectHeight();\n      var targetAlign = syncState.targetAlign,\n          originAlign = syncState.originAlign,\n          index = syncState.index,\n          offset = syncState.offset;\n      var height = containerRef.current.clientHeight;\n      var needCollectHeight = false;\n      var newTargetAlign = targetAlign;\n      var targetTop = null; // Go to next frame if height not exist\n\n      if (height) {\n        var mergedAlign = targetAlign || originAlign; // Get top & bottom\n\n        var stackTop = 0;\n        var itemTop = 0;\n        var itemBottom = 0;\n        var maxLen = Math.min(data.length - 1, index);\n\n        for (var i = 0; i <= maxLen; i += 1) {\n          var key = getKey(data[i]);\n          itemTop = stackTop;\n          var cacheHeight = heights.get(key);\n          itemBottom = itemTop + (cacheHeight === undefined ? itemHeight : cacheHeight);\n          stackTop = itemBottom;\n        } // Check if need sync height (visible range has item not record height)\n\n\n        var leftHeight = mergedAlign === 'top' ? offset : height - offset;\n\n        for (var _i = maxLen; _i >= 0; _i -= 1) {\n          var _key = getKey(data[_i]);\n\n          var _cacheHeight = heights.get(_key);\n\n          if (_cacheHeight === undefined) {\n            needCollectHeight = true;\n            break;\n          }\n\n          leftHeight -= _cacheHeight;\n\n          if (leftHeight <= 0) {\n            break;\n          }\n        } // Scroll to\n\n\n        switch (mergedAlign) {\n          case 'top':\n            targetTop = itemTop - offset;\n            break;\n\n          case 'bottom':\n            targetTop = itemBottom - height + offset;\n            break;\n\n          default:\n            {\n              var scrollTop = containerRef.current.scrollTop;\n              var scrollBottom = scrollTop + height;\n\n              if (itemTop < scrollTop) {\n                newTargetAlign = 'top';\n              } else if (itemBottom > scrollBottom) {\n                newTargetAlign = 'bottom';\n              }\n            }\n        }\n\n        if (targetTop !== null) {\n          syncScrollTop(targetTop);\n        } // One more time for sync\n\n\n        if (targetTop !== syncState.lastTop) {\n          needCollectHeight = true;\n        }\n      } // Trigger next effect\n\n\n      if (needCollectHeight) {\n        setSyncState(_objectSpread(_objectSpread({}, syncState), {}, {\n          times: syncState.times + 1,\n          targetAlign: newTargetAlign,\n          lastTop: targetTop\n        }));\n      }\n    } else if (process.env.NODE_ENV !== 'production' && (syncState === null || syncState === void 0 ? void 0 : syncState.times) === MAX_TIMES) {\n      warning(false, 'Seems `scrollTo` with `rc-virtual-list` reach the max limitation. Please fire issue for us. Thanks.');\n    }\n  }, [syncState, containerRef.current]); // =========================== Scroll To ===========================\n\n  return function (arg) {\n    // When not argument provided, we think dev may want to show the scrollbar\n    if (arg === null || arg === undefined) {\n      triggerFlash();\n      return;\n    } // Normal scroll logic\n\n\n    raf.cancel(scrollRef.current);\n\n    if (typeof arg === 'number') {\n      syncScrollTop(arg);\n    } else if (arg && _typeof(arg) === 'object') {\n      var index;\n      var align = arg.align;\n\n      if ('index' in arg) {\n        index = arg.index;\n      } else {\n        index = data.findIndex(function (item) {\n          return getKey(item) === arg.key;\n        });\n      }\n\n      var _arg$offset = arg.offset,\n          offset = _arg$offset === void 0 ? 0 : _arg$offset;\n      setSyncState({\n        times: 0,\n        index: index,\n        offset: offset,\n        originAlign: align\n      });\n    }\n  };\n}","map":{"version":3,"names":["_typeof","_objectSpread","_slicedToArray","React","raf","useLayoutEffect","warning","MAX_TIMES","useScrollTo","containerRef","data","heights","itemHeight","getKey","collectHeight","syncScrollTop","triggerFlash","scrollRef","useRef","_React$useState","useState","_React$useState2","syncState","setSyncState","times","current","ori","targetAlign","originAlign","index","offset","height","clientHeight","needCollectHeight","newTargetAlign","targetTop","mergedAlign","stackTop","itemTop","itemBottom","maxLen","Math","min","length","i","key","cacheHeight","get","undefined","leftHeight","_i","_key","_cacheHeight","scrollTop","scrollBottom","lastTop","process","env","NODE_ENV","arg","cancel","align","findIndex","item","_arg$offset"],"sources":["/Users/joji/Documents/CODE/React/react-cutioluis/node_modules/rc-virtual-list/es/hooks/useScrollTo.js"],"sourcesContent":["import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\n/* eslint-disable no-param-reassign */\nimport * as React from 'react';\nimport raf from \"rc-util/es/raf\";\nimport useLayoutEffect from \"rc-util/es/hooks/useLayoutEffect\";\nimport { warning } from 'rc-util';\nvar MAX_TIMES = 10;\nexport default function useScrollTo(containerRef, data, heights, itemHeight, getKey, collectHeight, syncScrollTop, triggerFlash) {\n  var scrollRef = React.useRef();\n  var _React$useState = React.useState(null),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    syncState = _React$useState2[0],\n    setSyncState = _React$useState2[1];\n\n  // ========================== Sync Scroll ==========================\n  useLayoutEffect(function () {\n    if (syncState && syncState.times < MAX_TIMES) {\n      // Never reach\n      if (!containerRef.current) {\n        setSyncState(function (ori) {\n          return _objectSpread({}, ori);\n        });\n        return;\n      }\n      collectHeight();\n      var targetAlign = syncState.targetAlign,\n        originAlign = syncState.originAlign,\n        index = syncState.index,\n        offset = syncState.offset;\n      var height = containerRef.current.clientHeight;\n      var needCollectHeight = false;\n      var newTargetAlign = targetAlign;\n      var targetTop = null;\n\n      // Go to next frame if height not exist\n      if (height) {\n        var mergedAlign = targetAlign || originAlign;\n\n        // Get top & bottom\n        var stackTop = 0;\n        var itemTop = 0;\n        var itemBottom = 0;\n        var maxLen = Math.min(data.length - 1, index);\n        for (var i = 0; i <= maxLen; i += 1) {\n          var key = getKey(data[i]);\n          itemTop = stackTop;\n          var cacheHeight = heights.get(key);\n          itemBottom = itemTop + (cacheHeight === undefined ? itemHeight : cacheHeight);\n          stackTop = itemBottom;\n        }\n\n        // Check if need sync height (visible range has item not record height)\n        var leftHeight = mergedAlign === 'top' ? offset : height - offset;\n        for (var _i = maxLen; _i >= 0; _i -= 1) {\n          var _key = getKey(data[_i]);\n          var _cacheHeight = heights.get(_key);\n          if (_cacheHeight === undefined) {\n            needCollectHeight = true;\n            break;\n          }\n          leftHeight -= _cacheHeight;\n          if (leftHeight <= 0) {\n            break;\n          }\n        }\n\n        // Scroll to\n        switch (mergedAlign) {\n          case 'top':\n            targetTop = itemTop - offset;\n            break;\n          case 'bottom':\n            targetTop = itemBottom - height + offset;\n            break;\n          default:\n            {\n              var scrollTop = containerRef.current.scrollTop;\n              var scrollBottom = scrollTop + height;\n              if (itemTop < scrollTop) {\n                newTargetAlign = 'top';\n              } else if (itemBottom > scrollBottom) {\n                newTargetAlign = 'bottom';\n              }\n            }\n        }\n        if (targetTop !== null) {\n          syncScrollTop(targetTop);\n        }\n\n        // One more time for sync\n        if (targetTop !== syncState.lastTop) {\n          needCollectHeight = true;\n        }\n      }\n\n      // Trigger next effect\n      if (needCollectHeight) {\n        setSyncState(_objectSpread(_objectSpread({}, syncState), {}, {\n          times: syncState.times + 1,\n          targetAlign: newTargetAlign,\n          lastTop: targetTop\n        }));\n      }\n    } else if (process.env.NODE_ENV !== 'production' && (syncState === null || syncState === void 0 ? void 0 : syncState.times) === MAX_TIMES) {\n      warning(false, 'Seems `scrollTo` with `rc-virtual-list` reach the max limitation. Please fire issue for us. Thanks.');\n    }\n  }, [syncState, containerRef.current]);\n\n  // =========================== Scroll To ===========================\n  return function (arg) {\n    // When not argument provided, we think dev may want to show the scrollbar\n    if (arg === null || arg === undefined) {\n      triggerFlash();\n      return;\n    }\n\n    // Normal scroll logic\n    raf.cancel(scrollRef.current);\n    if (typeof arg === 'number') {\n      syncScrollTop(arg);\n    } else if (arg && _typeof(arg) === 'object') {\n      var index;\n      var align = arg.align;\n      if ('index' in arg) {\n        index = arg.index;\n      } else {\n        index = data.findIndex(function (item) {\n          return getKey(item) === arg.key;\n        });\n      }\n      var _arg$offset = arg.offset,\n        offset = _arg$offset === void 0 ? 0 : _arg$offset;\n      setSyncState({\n        times: 0,\n        index: index,\n        offset: offset,\n        originAlign: align\n      });\n    }\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}