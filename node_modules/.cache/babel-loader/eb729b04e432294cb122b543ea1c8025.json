{"ast":null,"code":"import * as React from 'react';\nimport { groupKeysMap } from '../../_util/transKeys';\n\nconst useData = (dataSource, rowKey, targetKeys) => {\n  const mergedDataSource = React.useMemo(() => (dataSource || []).map(record => {\n    if (rowKey) {\n      record = Object.assign(Object.assign({}, record), {\n        key: rowKey(record)\n      });\n    }\n\n    return record;\n  }), [dataSource, rowKey]);\n  const [leftDataSource, rightDataSource] = React.useMemo(() => {\n    const leftData = [];\n    const rightData = new Array((targetKeys || []).length);\n    const targetKeysMap = groupKeysMap(targetKeys || []);\n    mergedDataSource.forEach(record => {\n      // rightData should be ordered by targetKeys\n      // leftData should be ordered by dataSource\n      if (targetKeysMap.has(record.key)) {\n        rightData[targetKeysMap.get(record.key)] = record;\n      } else {\n        leftData.push(record);\n      }\n    });\n    return [leftData, rightData];\n  }, [mergedDataSource, targetKeys, rowKey]);\n  return [mergedDataSource, leftDataSource, rightDataSource];\n};\n\nexport default useData;","map":{"version":3,"names":["React","groupKeysMap","useData","dataSource","rowKey","targetKeys","mergedDataSource","useMemo","map","record","Object","assign","key","leftDataSource","rightDataSource","leftData","rightData","Array","length","targetKeysMap","forEach","has","get","push"],"sources":["/Users/joji/Documents/CODE/React/react-cutioluis/node_modules/antd/es/transfer/hooks/useData.js"],"sourcesContent":["import * as React from 'react';\nimport { groupKeysMap } from '../../_util/transKeys';\nconst useData = (dataSource, rowKey, targetKeys) => {\n  const mergedDataSource = React.useMemo(() => (dataSource || []).map(record => {\n    if (rowKey) {\n      record = Object.assign(Object.assign({}, record), {\n        key: rowKey(record)\n      });\n    }\n    return record;\n  }), [dataSource, rowKey]);\n  const [leftDataSource, rightDataSource] = React.useMemo(() => {\n    const leftData = [];\n    const rightData = new Array((targetKeys || []).length);\n    const targetKeysMap = groupKeysMap(targetKeys || []);\n    mergedDataSource.forEach(record => {\n      // rightData should be ordered by targetKeys\n      // leftData should be ordered by dataSource\n      if (targetKeysMap.has(record.key)) {\n        rightData[targetKeysMap.get(record.key)] = record;\n      } else {\n        leftData.push(record);\n      }\n    });\n    return [leftData, rightData];\n  }, [mergedDataSource, targetKeys, rowKey]);\n  return [mergedDataSource, leftDataSource, rightDataSource];\n};\nexport default useData;"],"mappings":"AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAASC,YAAT,QAA6B,uBAA7B;;AACA,MAAMC,OAAO,GAAG,CAACC,UAAD,EAAaC,MAAb,EAAqBC,UAArB,KAAoC;EAClD,MAAMC,gBAAgB,GAAGN,KAAK,CAACO,OAAN,CAAc,MAAM,CAACJ,UAAU,IAAI,EAAf,EAAmBK,GAAnB,CAAuBC,MAAM,IAAI;IAC5E,IAAIL,MAAJ,EAAY;MACVK,MAAM,GAAGC,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBF,MAAlB,CAAd,EAAyC;QAChDG,GAAG,EAAER,MAAM,CAACK,MAAD;MADqC,CAAzC,CAAT;IAGD;;IACD,OAAOA,MAAP;EACD,CAP4C,CAApB,EAOrB,CAACN,UAAD,EAAaC,MAAb,CAPqB,CAAzB;EAQA,MAAM,CAACS,cAAD,EAAiBC,eAAjB,IAAoCd,KAAK,CAACO,OAAN,CAAc,MAAM;IAC5D,MAAMQ,QAAQ,GAAG,EAAjB;IACA,MAAMC,SAAS,GAAG,IAAIC,KAAJ,CAAU,CAACZ,UAAU,IAAI,EAAf,EAAmBa,MAA7B,CAAlB;IACA,MAAMC,aAAa,GAAGlB,YAAY,CAACI,UAAU,IAAI,EAAf,CAAlC;IACAC,gBAAgB,CAACc,OAAjB,CAAyBX,MAAM,IAAI;MACjC;MACA;MACA,IAAIU,aAAa,CAACE,GAAd,CAAkBZ,MAAM,CAACG,GAAzB,CAAJ,EAAmC;QACjCI,SAAS,CAACG,aAAa,CAACG,GAAd,CAAkBb,MAAM,CAACG,GAAzB,CAAD,CAAT,GAA2CH,MAA3C;MACD,CAFD,MAEO;QACLM,QAAQ,CAACQ,IAAT,CAAcd,MAAd;MACD;IACF,CARD;IASA,OAAO,CAACM,QAAD,EAAWC,SAAX,CAAP;EACD,CAdyC,EAcvC,CAACV,gBAAD,EAAmBD,UAAnB,EAA+BD,MAA/B,CAduC,CAA1C;EAeA,OAAO,CAACE,gBAAD,EAAmBO,cAAnB,EAAmCC,eAAnC,CAAP;AACD,CAzBD;;AA0BA,eAAeZ,OAAf"},"metadata":{},"sourceType":"module"}